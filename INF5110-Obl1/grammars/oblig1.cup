package oblig1parser;

import java.util.*;
import java_cup.runtime.*;
import syntaxtree.*;
import syntaxtree.datatypes.*;
import syntaxtree.expressions.*;
import syntaxtree.expressions.literals.*;
import syntaxtree.statements.*;

parser code {:

	@Override
	public void unrecovered_syntax_error(Symbol s) throws ParserSyntaxException {
		StringBuilder sb = new StringBuilder();
		sb.append("Syntax error ");
		
		if (s.value != null) {
			sb.append("when reading '");
			sb.append(s.value);
			sb.append("' ");
		}
		
		sb.append("on line ");
		sb.append(s.left + 1);
		sb.append(", column ");
		sb.append(s.right + 1);
		sb.append(".");
		
		throw new ParserSyntaxException(sb.toString());
	}
:};

/* Terminals */
terminal                        PROGRAM, CLASS;
terminal                        LBRACK, RBRACK;
terminal                        LPAR, RPAR;
terminal						COLON;
terminal                        SEMI;
terminal						DOT;
terminal						COMMA;
terminal						ASSIGN;
terminal                        PROC;
terminal						REF;
terminal						VAR;
terminal						BOOL;
terminal						FLOAT;
terminal						INT;
terminal						STRING;
terminal						RETURN;
terminal						NEW;
terminal Float					FLOAT_LITERAL;
terminal Integer				INT_LITERAL;
terminal String                 ID;
terminal String                 STRING_LITERAL;

/* Non terminals */
non terminal Program				program;
non terminal List<Decl>				decl_list_opt, decl_list;
non terminal Decl					decl;
non terminal ProcedureDecl			proc_decl;
non terminal ClassDecl				class_decl;
non terminal VariableDecl			var_decl;
non terminal List<VariableDecl>		var_decl_list_opt, var_decl_list;
non terminal DataType				type, return_type;
non terminal ParameterDecl			param_decl;
non terminal List<ParameterDecl>	param_decl_list, param_decl_list_opt;
non terminal Boolean				param_decl_ref;
non terminal Literal				literal;
non terminal Statement				stmt;
non terminal List<Statement>		stmt_list, stmt_list_opt;
non terminal AssignStatement		assign_stmt;
non terminal ReturnStatement		return_stmt;
non terminal Expression				exp;
non terminal Variable				var;


/* The grammar */
start with program;

program
	::= PROGRAM LBRACK decl_list_opt:dl RBRACK
		{:
			RESULT = new Program(dl);
		:}
;

decl_list_opt
	::= decl_list:dl
		{:
			RESULT = dl;
		:}
	|	// empty (no declarations)
		{:
			RESULT = new LinkedList<Decl>();
		:}
;

decl_list
	::= decl:d
		{:
			List<Decl> l = new LinkedList<Decl>();
			l.add(d);
			RESULT = l;
		:}
	|	decl_list:dl decl:d
		{:
			dl.add(d);
			RESULT = dl;
		:}
;

decl
	::= var_decl:d
		{:
			RESULT = d;
		:}
	|	proc_decl:d
		{:
			RESULT = d;
		:}
	|	class_decl:d
		{:
			RESULT = d;
		:}
;

proc_decl
	::= PROC ID:name return_type:t LPAR param_decl_list_opt:pl RPAR LBRACK decl_list_opt:dl stmt_list_opt:sl RBRACK
		{:
			RESULT = new ProcedureDecl(name, t, pl, dl, sl);
		:}
;

return_type
	::=	COLON type:t
		{:
			RESULT = t;
		:}
	|	// empty
		{:
			RESULT = new VoidType();
		:}
;

param_decl_list_opt
	::=	param_decl_list:pl
		{:
			RESULT = pl;
		:}
	|	// empty
		{:
			RESULT = new LinkedList<ParameterDecl>();
		:}
;

param_decl_list
	::=	param_decl:pd
		{:
			List<ParameterDecl> l = new LinkedList<ParameterDecl>();
			l.add(pd);
			RESULT = l;
		:}
	|	param_decl_list:pl COMMA param_decl:pd
		{:
			pl.add(pd);
			RESULT = pl;
		:}
;

param_decl
	::=	param_decl_ref:r ID:name COLON type:t
		{:
			RESULT = new ParameterDecl(r.booleanValue(), name, t);
		:}
;

param_decl_ref
	::=	REF
		{:
			RESULT = true;
		:}
	|	// empty
		{:
			RESULT = false;
		:}
;

var_decl
	::= VAR ID:name COLON type:t SEMI
		{:
			RESULT = new VariableDecl(name, t);
		:}
;

class_decl
	::= CLASS ID:name LBRACK var_decl_list_opt:vl RBRACK
		{:
			RESULT = new ClassDecl(name, vl);
		:}
;

var_decl_list_opt
	::= var_decl_list:vl
		{:
			RESULT = vl;
		:}
	|	// empty (no variable declarations)
		{:
			RESULT = new LinkedList<VariableDecl>();
		:}
;
				
var_decl_list
	::= var_decl:vd
		{:
			List<VariableDecl> l = new LinkedList<VariableDecl>();
			l.add(vd);
			RESULT = l;
		:}
	|	var_decl_list:vl var_decl:vd
		{:
			vl.add(vd);
			RESULT = vl;
		:}
;

exp
	::=	literal:l
		{:
			RESULT = l;
		:}
	|	NEW ID:name
		{:
			RESULT = new NewExpression(new ClassType(name));
		:}
	|	var:v
		{:
			RESULT = v;
		:}
;

var
	::=	exp:e DOT ID:name
		{:
			RESULT = new Variable(name, e);
		:}
	|	ID:name
		{:
			RESULT = new Variable(name);
		:}
;

literal
	::=	INT_LITERAL:i
		{:
			RESULT = new IntLiteral(i);
		:}
	|	FLOAT_LITERAL:f
		{:
			RESULT = new FloatLiteral(f);
		:}
;

stmt_list_opt
	::=	stmt_list:sl
		{:
			RESULT = sl;
		:}
	|	// empty
		{:
			RESULT = new LinkedList<Statement>();
		:}
;

stmt_list
	::=	stmt:s
		{:
			List<Statement> l = new LinkedList<Statement>();
			l.add(s);
			RESULT = l;
		:}
	|	stmt_list:sl stmt:s
		{:
			sl.add(s);
			RESULT = sl;
		:}
;

stmt
	::= assign_stmt:s SEMI
		{:
			RESULT = s;
		:}
	|	return_stmt:s SEMI
		{:
			RESULT = s;
		:}
;

assign_stmt
	::=	var:v ASSIGN exp:e
		{:
			RESULT = new AssignStatement(v, e);
		:}
;

return_stmt
	::=	RETURN
		{:
			RESULT = new ReturnStatement();
		:}
	|	RETURN exp:e
		{:
			RESULT = new ReturnStatement(e);
		:}
;

type
	::= BOOL
		{:
			RESULT = new BoolType();
		:}
	|	FLOAT
		{:
			RESULT = new FloatType();
		:}
	|	INT
		{:
			RESULT = new IntType();
		:}
	|	STRING
		{:
			RESULT = new StringType();
		:}
	|	ID:name
		{:
			RESULT = new ClassType(name);
		:}
;
