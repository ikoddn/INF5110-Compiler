package oblig1parser;
import java_cup.runtime.*;
import syntaxtree.*;
import syntaxtree.datatypes.*;
import java.util.*;

parser code {:

:};

/* Terminals */
terminal                        PROGRAM, CLASS;
terminal                        LBRACK, RBRACK;
terminal                        LPAR, RPAR;
terminal						COLON;
terminal                        SEMI, RETURN;
terminal						COMMA;
terminal                        PROCEDURE;
terminal						REFERENCE;
terminal						VARIABLE;
terminal						BOOL;
terminal						FLOAT;
terminal						INT;
terminal						STRING;
terminal String                 ID;
terminal String                 STRING_LITERAL;

/* Non terminals */
non terminal Program				program;
non terminal List<Decl>				decl_list_opt, decl_list;
non terminal Decl					decl;
non terminal ProcedureDecl			proc_decl;
non terminal ClassDecl				class_decl;
non terminal VarDecl				var_decl;
non terminal List<VarDecl>			var_decl_list_opt, var_decl_list;
non terminal DataType				type, proc_decl_type;
non terminal ParameterDecl			param_decl;
non terminal List<ParameterDecl>	param_decl_list, param_decl_list_opt;
non terminal Boolean				param_decl_ref;


/* The grammar */
program
	::= PROGRAM LBRACK decl_list_opt:dl RBRACK
		{:
			RESULT = new Program(dl);
		:}
;

decl_list_opt
	::= decl_list:dl
		{:
			RESULT = dl;
		:}
	|	// empty (no declarations)
		{:
			RESULT = new LinkedList<Decl>();
		:}
;

decl_list
	::= decl:d
		{:
			List<Decl> l = new LinkedList<Decl>();
			l.add(d);
			RESULT = l;
		:}
	|	decl_list:dl decl:d
		{:
			dl.add(d);
			RESULT = dl;
		:}
;

decl
	::= var_decl:d
		{:
			RESULT = d;
		:}
	|	proc_decl:d
		{:
			RESULT = d;
		:}
	|	class_decl:d
		{:
			RESULT = d;
		:}
;

proc_decl
	::= PROCEDURE ID:name proc_decl_type:t LPAR param_decl_list_opt:pl RPAR LBRACK decl_list_opt:dl RBRACK
		{:
			RESULT = new ProcedureDecl(name, t, pl, dl);
		:}
;

proc_decl_type
	::=	COLON type:t
		{:
			RESULT = t;
		:}
	|	// empty
		{:
			RESULT = new VoidType();
		:}
;

param_decl_list_opt
	::=	param_decl_list:pl
		{:
			RESULT = pl;
		:}
	|	// empty
		{:
			RESULT = new LinkedList<ParameterDecl>();
		:}
;

param_decl_list
	::=	param_decl:pd
		{:
			List<ParameterDecl> l = new LinkedList<ParameterDecl>();
			l.add(pd);
			RESULT = l;
		:}
	|	param_decl_list:pl COMMA param_decl:pd
		{:
			pl.add(pd);
			RESULT = pl;
		:}
;

param_decl
	::=	param_decl_ref:r ID:name COLON type:t
		{:
			RESULT = new ParameterDecl(r.booleanValue(), name, t);
		:}
;

param_decl_ref
	::=	REFERENCE
		{:
			RESULT = true;
		:}
	|	// empty
		{:
			RESULT = false;
		:}
;

var_decl
	::= VARIABLE ID:name COLON type:t SEMI
		{:
			RESULT = new VarDecl(name, t);
		:}
;

class_decl
	::= CLASS ID:name LBRACK var_decl_list_opt:vl RBRACK
		{:
			RESULT = new ClassDecl(name, vl);
		:}
;

var_decl_list_opt
	::= var_decl_list:vl
		{:
			RESULT = vl;
		:}
	|	// empty (no variable declarations)
		{:
			RESULT = new LinkedList<VarDecl>();
		:}
;
				
var_decl_list
	::= var_decl:vd
		{:
			List<VarDecl> l = new LinkedList<VarDecl>();
			l.add(vd);
			RESULT = l;
		:}
	|	var_decl_list:vl var_decl:vd
		{:
			vl.add(vd);
			RESULT = vl;
		:}
;

type
	::= BOOL
		{:
			RESULT = new BoolType();
		:}
	|	FLOAT
		{:
			RESULT = new FloatType();
		:}
	|	INT
		{:
			RESULT = new IntType();
		:}
	|	STRING
		{:
			RESULT = new StringType();
		:}
	|	ID:name
		{:
			RESULT = new ClassType(name);
		:}
;
